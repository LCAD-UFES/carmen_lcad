#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <carmen/carmen.h>
#include <prob_measurement_model.h>
#include <prob_map.h>
#include <prob_interface.h>
#include <prob_measurement_model.h>
#include <prob_transforms.h>
#include <carmen/fused_odometry_interface.h>
#include <carmen/velodyne_interface.h>
#include <carmen/laser_ldmrs_interface.h>
#include <carmen/laser_ldmrs_utils.h>
#include <carmen/rotation_geometry.h>
#include <carmen/mapper_interface.h>
#include <carmen/stereo_velodyne.h>
#include <carmen/stereo_velodyne_interface.h>
#include <carmen/grid_mapping.h>
#include <carmen/stereo_mapping_interface.h>
#include <carmen/map_server_interface.h>
#include <carmen/rddf_messages.h>
#include <carmen/rddf_interface.h>
#include <carmen/rddf_util.h>
#include <carmen/ultrasonic_filter_interface.h>
#include <carmen/parking_assistant_interface.h>
#include <omp.h>
#include "mapper.h"
#include <carmen/road_mapper.h>
#include <iostream>
#include <opencv2/opencv.hpp>
#include <vector>

static const double local_gridmap_resolution = 0.04;

// era um mapa de 150m, resolução de 0.2m, portanto 150/02 = 750 pixels, que dividido por 3 dava 250 por ladrilho, no caso da IARA
static const double local_gridmap_size = 350 * 3 * local_gridmap_resolution;  //LOCAL_MAP_SIZE; 

static const int local_gridmap_count   = local_gridmap_size / local_gridmap_resolution;
static const int local_gridmap_count_3 = (local_gridmap_size/3) / local_gridmap_resolution;

static double*
carmen_map_converter_get_cell_pointer(double *map, int cell_number)
{
	switch (cell_number)
	{
	case 0:
		return map;
		break;
	case 1:
		return &map[local_gridmap_count * local_gridmap_count_3];
		break;
	case 2:
		return &map[local_gridmap_count * 2 * local_gridmap_count_3];
		break;
	case 3:
		return &map[local_gridmap_count_3];
		break;
	case 4:
		return &map[local_gridmap_count * local_gridmap_count_3 + local_gridmap_count_3];
		break;
	case 5:
		return &map[local_gridmap_count * 2 * local_gridmap_count_3 + local_gridmap_count_3];
		break;
	case 6:
		return &map[2 * local_gridmap_count_3];
		break;
	case 7:
		return &map[2 * local_gridmap_count_3 + local_gridmap_count * local_gridmap_count_3];
		break;
	case 8:
		return &map[2 * local_gridmap_count_3 + local_gridmap_count * local_gridmap_count_3 * 2];
		break;
	}
	return (NULL);
}

static void
carmen_map_converter_copy_map_to_cell(double **cell, carmen_map_t *map, int cell_number)
{
	double *map_cell = carmen_map_converter_get_cell_pointer(map->complete_map, cell_number);

	for (int i = 0; i < local_gridmap_count_3; i++)
		memcpy(cell[i], map_cell + i * local_gridmap_count, local_gridmap_count_3 * sizeof(double));
}

static int
carmen_map_converter_grid_mapping_save_block_map_by_origin(char *map_path, char map_type, carmen_map_t *map)
{
	carmen_map_t *unk_map = (carmen_map_t *) calloc(1, sizeof(carmen_map_t));
	carmen_grid_mapping_initialize_map(unk_map, local_gridmap_count_3, local_gridmap_resolution, map_type);

	for (int i = 0, k = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++, k++)
		{
			int x_origin = map->config.x_origin + j * local_gridmap_size / 3.0;
			int y_origin = map->config.y_origin + i * local_gridmap_size / 3.0;

			carmen_map_converter_copy_map_to_cell(unk_map->map, map, k);

			char full_map_path[100];
			sprintf(full_map_path, "%s/%c%d_%d.map", map_path, map_type,
					x_origin, y_origin);

			carmen_FILE *fp = carmen_fopen(full_map_path, "w+");

			if (fp == NULL)
			{
				fprintf(stderr, "Could not write map to file: %s\n", full_map_path);
				fflush(stderr);
				return 0;
			}

			if (carmen_map_write_all(fp, unk_map->map,
					map->config.x_size / 3,
					map->config.y_size / 3,
					map->config.resolution,
					(char*)"",	(char*)"", (char*)"", (char*)"Generated by big_map",
					NULL, 0, NULL, 0, NULL, 0) == -1)
				return (0);

			carmen_fclose(fp);
		}
	}

	free(unk_map->map);
	free(unk_map->complete_map);
	free(unk_map);

	return (1);
}

void
carmen_map_fill_map(carmen_map_t* map, int new_size_x, int new_size_y)
{

    double*  new_complete_map = (double*)   calloc(new_size_x * new_size_y, sizeof(double));
    double** new_empty_map    = (double **) calloc(new_size_x, sizeof(double *));

    for(int i = 0; i < new_size_x; i ++)
    {
        for(int j = 0; j < new_size_y; j++)
        {
            new_complete_map[i * new_size_y + j] = -1.0;
        }
    }

    // // Se o tamanho do mapa for maior que o tamanho de um ladrilho, começa a montar o mapa do canto inferior esquerdo
    // if(map->config.x_size > local_gridmap_count_3 && map->config.y_size > local_gridmap_count_3)
    // {

        for(int i = 0; i < new_size_x; i++)
        {
            new_empty_map[i] = &(new_complete_map[i * new_size_y]);
            if(i < map->config.x_size)
                memcpy((void*) new_empty_map[i], (void*) map->map[i], map->config.y_size * sizeof(double));
        }

    // } 
    // else // Se o mapa for pequeno o suficiente, coloca ele no ladrilho do meio
    // {
        // for(int i = 0; i < new_size_x; i++)
        // {
        //     new_empty_map[i] = &(new_complete_map[i * new_size_y]);
        // }
        // for(int i = 0; i < map->config.x_size; i++)
        // {
        //     memcpy((void*) new_empty_map[i + local_gridmap_count_3], (void*) map->map[i], map->config.y_size * sizeof(double));
        // }

    // }

    free(map->map);
    free(map->complete_map);

    map->complete_map  = new_complete_map;
    map->map           = new_empty_map;
    map->config.x_size = new_size_x;
    map->config.y_size = new_size_y;

}

carmen_map_t*
carmen_map_converter_read_map_from_pgm(const char* filePath)
{
    // Carrega a imagem .pgm em escala de cinza
    cv::Mat image = cv::imread(filePath, cv::IMREAD_GRAYSCALE);
    if (image.empty()) {
        std::cerr << "Erro ao carregar o arquivo " << filePath << std::endl;
        return NULL;
    }
    carmen_map_config_t config;
    config.x_size = image.cols;
    config.y_size = image.rows;
    config.resolution = local_gridmap_resolution;

    config.x_origin = 980.0;
    config.y_origin = 980.0;
    config.map_name = (char*) "mapa_teste";
 
    carmen_map_t* map = carmen_map_interface_create_new_empty_map(&config);
    for (int i = 0; i < map->config.x_size; i++)
    {
        for (int j = 0; j < map->config.y_size; j++)
        {
            double value_pixel = 1 - static_cast<double>(image.at<uchar>(j, i)) / 255.0;
            if(value_pixel < 0.1 || value_pixel > 0.9)
                map->map[i][config.y_size - 1 - j] = value_pixel;
            else
                map->map[i][config.y_size - 1 - j] = -1.0;
        }
    }

    return map;
}

int
main(int argc, char **argv)
{
	char* map_path;
	char* map_destiny;
	if(argc > 2)
	{
		map_path = argv[1];
		map_destiny = argv[2];
	}
	else
	{
		printf("Passe o caminho para o arquivo .pgm e o destino\n");
		printf("Exemplo: ./carmen_map_converter teste_pgm.pgm ../data/ros_to_carmen_converted_map\n");
		return 0;
	}
	carmen_map_t* map = carmen_map_converter_read_map_from_pgm(map_path);

	carmen_map_fill_map(map, local_gridmap_count, local_gridmap_count);
	//carmen_map_write_to_ppm(map, (char*)"map.ppm");

	// carmen_grid_mapping_save_map((char*)"map.map", map);
	carmen_map_converter_grid_mapping_save_block_map_by_origin(map_destiny, 'm', map);
	carmen_map_converter_grid_mapping_save_block_map_by_origin(map_destiny, 'o', map);
	carmen_map_converter_grid_mapping_save_block_map_by_origin(map_destiny, 'u', map);
	// carmen_map_converter_save_block_map_by_origin((char*) "my_map", 'm', map);

	carmen_map_destroy(&map);
    return (0);
}