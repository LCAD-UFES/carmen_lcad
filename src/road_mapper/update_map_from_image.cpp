#include "road_mapper_utils.h"
#include <vector>


char *g_input_dir = (char *) ".";
char *g_out_dir = (char *) ".";
char *g_image_file;
cv::Mat g_image;
double g_x_origin;
double g_y_origin;
int g_x_size = 350;
int g_y_size = 350;
double g_resolution = 0.2;
std::vector<cv::Vec3b> g_bad_colors;


void
prog_usage(char *prog_name, const char *error_msg = NULL, const char *error_msg2 = NULL)
{
	if (error_msg)
		fprintf(stderr, "\n%s", error_msg);
	if (error_msg2)
		fprintf(stderr, "%s", error_msg2);

	fprintf(stderr, "\n\nUsage:    %s   <image_file>  -input_dir <map_dir>  -out_dir <map_dir>  -resolution <meters>  -x_size <num>  -y_size <num>\n", prog_name);
	fprintf(stderr,    "defaults: %*c                 -input_dir .          -out_dir .          -resolution 0.2       -x_size 350    -y_size 350\n\n", int(strlen(prog_name)), ' ');

	exit(-1);
}


char *
validate_image_limits()
{
	char *result = (char *) calloc(2000, sizeof(char));

	double x_size_meters = (double) g_x_size * g_resolution;
	double y_size_meters = (double) g_y_size * g_resolution;

	if (fmod(g_x_origin, x_size_meters) > 0.0001)
		sprintf(result, "Image x_origin (%lf) is not a multiple of map x_size (%d * %lf)", g_x_origin, g_x_size, g_resolution);
	else if (fmod(g_y_origin, y_size_meters) > 0.0001)
		sprintf(result, "Image y_origin (%lf) is not a multiple of map y_size (%d * %lf)", g_y_origin, g_y_size, g_resolution);
	else if ((g_image.cols % g_x_size) != 0)
		sprintf(result, "Image columns (%d) is not a multiple of map x_size (%d)", g_image.cols, g_x_size);
	else if ((g_image.rows % g_y_size) != 0)
		sprintf(result, "Image rows (%d) is not a multiple of map y_size (%d)", g_image.rows, g_y_size);

	if (*result)
		return result;
	free(result);
	return NULL;
}


static int
get_map_origin_by_filename(char *full_path, double *x_origin, double *y_origin, char map_type = 'm')
{
	char *filename, *file_extension;
	double x, y;
	int pos;

	*x_origin = *y_origin = 0.0;

	filename = strrchr(full_path, '/');
	if (filename == NULL)
		filename = full_path;
	else
		filename++;

	if (strncmp(filename, "complete_", 9) == 0)
		filename += 9;

	file_extension = strrchr(filename, '.');
	if (file_extension == NULL)
		file_extension = filename + strlen(filename);
	else
		file_extension++;

	if (filename[0] == map_type && sscanf(filename, "%*c%lf_%lf%n", &x, &y, &pos) == 2 && (filename + pos) == file_extension)
	{
		*x_origin = x;
		*y_origin = y;
		return 0;
	}
	return -1;
}


#define IS_CELL_UNKNOWN(x)		((x) == cv::Vec3b(255,   0,   0) || (x) == cv::Vec3b(255, 144, 30)) /* blue or bluish */
#define IS_CELL_UNOCCUPIED(x)	((x) == cv::Vec3b(255, 255, 255)) /* white */
#define IS_CELL_OCCUPIED(x)		((x) == cv::Vec3b(  0,   0,   0)) /* black */
#define IS_CELL_BLOCKED(x)		((x) == cv::Vec3b(  0,   0, 255)) /* red */
#define IS_CELL_GRAY(x)			((x)[0] == (x)[1] && (x)[1] == (x)[2]) /* gray */


bool
map_img_is_empty(cv::Mat &map_img)
{
	for (int row = 0; row < map_img.rows; row++)
		for (int col = 0; col < map_img.cols; col++)
			if (!IS_CELL_UNKNOWN(map_img.at<cv::Vec3b>(row, col)))
				return false;

	return true;
}


int
save_map(char *map_file_name, carmen_map_t *map)
{
	char *description = (char *) "Generated by update_map_from_image";
	carmen_FILE *fp = carmen_fopen(map_file_name, "w+");

	if (fp == NULL)
	{
		fprintf(stderr, "Could not open file for writing: %s\n", map_file_name);
		return -1;
	}

	if (carmen_map_write_all(fp, map->map,
			map->config.x_size,
			map->config.y_size,
			map->config.resolution,
			(char *) "", description, (char *) "", description,
			NULL, 0, NULL, 0, NULL, 0) == -1)
	{
		fprintf(stderr, "Could not write map file: %s\n", map_file_name);
		return -1;
	}

	carmen_fclose(fp);
	return 0;
}


void
update_map(char *out_path, cv::Mat &img, int top __attribute__ ((unused)), int left __attribute__ ((unused)), carmen_map_t *map, bool new_map = false)
{
	for (int x = 0; x < img.cols; x++)
	{
		int img_left = x;
		for (int y = 0; y < img.rows; y++)
		{
			int img_top = img.rows - y - 1;
			cv::Vec3b cell = img.at<cv::Vec3b>(img_top, img_left);
			if (IS_CELL_UNKNOWN(cell))
				map->map[x][y] = -1.0;
			else if (IS_CELL_UNOCCUPIED(cell))
				map->map[x][y] = 0.0;
			else if (IS_CELL_OCCUPIED(cell))
				map->map[x][y] = 1.0;
			else if (IS_CELL_BLOCKED(cell))
				map->map[x][y] = -2.0;
			else if (IS_CELL_GRAY(cell))
			{
				if (new_map)
					map->map[x][y] = 1.0 - (double(cell[0]) / 255.0);
			}
			else
			{
				map->map[x][y] = -1.0;
			}
			// {
			// 	if (new_map)
			// 		map->map[x][y] = -1.0;

			// 	if (std::find(g_bad_colors.begin(), g_bad_colors.end(), cell) == g_bad_colors.end())
			// 	{
			// 		map->map[x][y] = -1.0;
			// 		fprintf(stderr, "Invalid image color at position (%d, %d): RGB(%d, %d, %d)\n", (top + img_top), (left + img_left), cell[2], cell[1], cell[0]);
			// 		g_bad_colors.push_back(cell);
			// 	}
			// }
		}
	}
	save_map(out_path, map);
}


void
create_map(char *out_path, cv::Mat &img, int top, int left)
{
	carmen_map_t map;
	memset(&map, 0, sizeof(carmen_map_t));

	map.config.x_size = g_x_size;
	map.config.y_size = g_y_size;
	map.config.resolution = g_resolution;
	map.config.x_origin = g_x_origin + (left * g_resolution);
	map.config.y_origin = g_y_origin + ((g_image.rows - top - g_y_size) * g_resolution);
	map.complete_map = (double *) malloc(sizeof(double) * g_x_size * g_y_size);
	carmen_test_alloc(map.complete_map);
	map.map = (double **) malloc(sizeof(double *) * g_x_size);
	carmen_test_alloc(map.map);
	for (int x = 0; x < g_x_size; x++)
		map.map[x] = &(map.complete_map[x * g_y_size]);

	update_map(out_path, img, top, left, &map, true);
	carmen_map_free_gridmap(&map);
}


void
update_all_maps()
{
	char input_path[1000], out_path[1000];
	cv::Mat block_img;
	carmen_map_t block_map;
	memset(&block_map, 0, sizeof(carmen_map_t));
	int image_block_cols = g_image.cols / g_x_size;
	int image_block_rows = g_image.rows / g_y_size;

	for (int col = 0; col < image_block_cols; col++)
	{
		int left = col * g_x_size;
		double map_x_origin = g_x_origin + (col * g_x_size * g_resolution);
		for (int row = 0; row < image_block_rows; row++)
		{
			int top  = g_image.rows - row * g_y_size - g_y_size;
			block_img = g_image(cv::Rect(left, top, g_x_size, g_y_size));
			double map_y_origin = g_y_origin + (row * g_y_size * g_resolution);
			sprintf(input_path, "%s/%c%d_%d.map", g_input_dir, 'm', int(map_x_origin), int(map_y_origin));
			sprintf(out_path,   "%s/%c%d_%d.map", g_out_dir,   'm', int(map_x_origin), int(map_y_origin));
			if (carmen_map_read_gridmap_chunk(input_path, &block_map) == 0)
				update_map(out_path, block_img, top, left, &block_map);
			else if (!map_img_is_empty(block_img))
				create_map(out_path, block_img, top, left);
			carmen_map_free_gridmap(&block_map);
			block_img.release();
		}
	}
}


static void
read_parameters(int argc, char **argv)
{
	char *result = NULL;

	g_image_file = argv[1];
	g_image = cv::imread(g_image_file);
	if (g_image.empty())
		prog_usage(argv[0], "Invalid image file content: ", g_image_file);
	if (get_map_origin_by_filename(g_image_file, &g_x_origin, &g_y_origin, 'm') != 0)
		prog_usage(argv[0], "Invalid image file name (complete_m<x>_<y> or m<x>_<y>): ", g_image_file);

	for (int i = 2; i < argc; i += 2)
	{
		if (strcmp(argv[i], "-input_dir") == 0)
			result = get_param(&g_input_dir, argc, argv, i, CARMEN_PARAM_DIR);
		else if (strcmp(argv[i], "-out_dir") == 0)
			result = get_param(&g_out_dir, argc, argv, i, CARMEN_PARAM_DIR);
		else if (strcmp(argv[i], "-resolution") == 0)
			result = get_param(&g_resolution, argc, argv, i, CARMEN_PARAM_DOUBLE);
		else if (strcmp(argv[i], "-x_size") == 0)
			result = get_param(&g_x_size, argc, argv, i, CARMEN_PARAM_INT);
		else if (strcmp(argv[i], "-y_size") == 0)
			result = get_param(&g_y_size, argc, argv, i, CARMEN_PARAM_INT);
		else
			prog_usage(argv[0], "Invalid option: ", argv[i]);
		if (result != NULL)
			prog_usage(argv[0], result);
	};

	result = validate_image_limits();
	if (result != NULL)
		prog_usage(argv[0], result);
}


void
shutdown_module(int signo)
{
	if (signo == SIGINT)
	{
		fprintf(stderr,"\nInterrupt signal received\n\n");
		exit(0);
	}
}


int
main(int argc, char **argv)
{
	if (argc < 2 || strcmp(argv[1], "-h") == 0)
		prog_usage(argv[0]);

	signal(SIGINT, shutdown_module);
	read_parameters(argc, argv);

	update_all_maps();

	return 0;
}
