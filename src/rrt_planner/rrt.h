/*
 * rrt.h
 *
 *  Created on: 16/12/2011
 *      Author: rradaelli
 */
#ifndef RRT_H_
#define RRT_H_

#include "model/tree.h"
#include "util/ackerman.h"

typedef enum
{
	REACHED_GOAL, ADVANCED, TRAPPED
} Return_Types;


class RRT
{
public:
	RRT();

	virtual void build_rrt_path() {};

	virtual void compute_x_new_alternatives_and_associated_commands_and_times(vector<RRT_Node *> &x_new_alternatives_computed,
			vector<Command> &x_new_associated_commands, vector<double> &x_new_associated_commands_times, RRT_Node &x_near, Pose &x_rand) = 0;

	void check_necessary_conditions_and_build_rrt_path();

	virtual void build_rrt_path_from_robot_pose(Robot_State &robot_pose) = 0;

	bool set_goal(Pose &goal_pose);

	void clear_the_search_tree_and_current_path();

	virtual ~RRT();

	void smooth_path(RRT_Node *goal_node);

	void update_adjacenty_nodes_cost(RRT_Node *node);

	/**
	 * Generate a random node that is on the free space of the map
	 * @param p_goal_bias: probability to choose the goal_pose as random node
	 */
	Pose random_conf(double p_goal_bias = 0, double radius = 2);

	Pose random_conf_normal();

	Pose ramdom_conf_goal_zoom(double radius);

	/**
	 * Set the condition to stop the algorithm
	 * distance_threshold in meters
	 * theta_threshold in radians
	 */
	void set_stop_condition(double distance_threshold, double theta_threshold);

	/**
	 * If the distance between the robot pose and the expected robot pose in the path
	 * is higher than distance, the path will be regenerated
	 */
	void set_change_path_condition(double distance, double theta);

	void publish_status_message();

//private:
	RRT_Node *extend(Pose &rand, RRT_Node *near, int *status);
	RRT_Node *connect(Pose &rand, RRT_Node *near, int *status, int max_extend = 9);//see RRT-Connect: An Efficient Approach to Single-Query Path Planning
	bool	  node_reaches_goal(RRT_Node *new_node);
	bool	  pose_reaches_goal(Pose &pose);

	RRT_Node* reuse_last_path(int num_reused_nodes, int &status);

	bool is_valid_path();

	//caso o status retornado seja reached constroi o path se ele for menor que o j√° existente e retorna true
	bool reached_verification(int &status, RRT_Node *new_node);

	bool reached_verification_no_prune(const int &status, RRT_Node *new_node);

	/**
	 * Maximize nodes cvf that dist is bigger than distance
	 */
	void prune_nodes();

	void smooth_principal_path_from_tree_using_conjugate_gradient (RRT_Node *goal);

	void get_path(RRT_Node *goal);


public:
	list<RRT_Path_Edge> path; //the path generated by the algorithm
	double path_timestamp; //timestamp da localizacao usada para gerar esse caminho
	double build_time; // tempo gasto para encontrar o caminho

	list<RRT_Path_Edge> old_path;
	double old_path_timestamp;
	double old_build_time;

	Tree   tree; //tree rooted on robot
	Pose  *goal_pose;

	bool goal_zoom;
	double goal_bias_probability; //probabilidade de goal_pose ser escolhido como ponto randomico na funcao random_conf

	double distance_threshold;
	double theta_threshold;

	double change_path_distance;
	double change_path_theta;

	vector<RRT_Node *> reaches_goal_nodes;
};

#endif /* RRT_H_ */
